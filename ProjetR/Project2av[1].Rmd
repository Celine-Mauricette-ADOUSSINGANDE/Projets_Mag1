---
title: "MAG 1 Project based on Dustmann et al. (2016, JEP)"
date: "January 5, 2024"
output:
  html_document:
    toc: yes
    toc_float: yes
    keep_md: yes
    fig_caption: yes
    df_print: tibble
    fig_width: 8.5
    theme: readable
  html_notebook:
    fig_width: 10
    fig_caption: yes
    toc: yes
    theme: readable
  pdf_document:
    toc: yes
---

```{=html}
<style>
  body {
    font-size: 105%;  /* Adjust the font size for regular text */
  }

  pre, code, kbd, samp {
    font-size: 105%;  /* Adjust the font size for code chunks */
  }
</style>
```
## L’impact de l’immigration : pourquoi les études aboutissent-elles à des résultats si différents ?

Projet réalisé par :

-   **ADJANOHOUN Brayann**
-   **ADOUSSINGANDE Céline**
-   **COMLAN Cybelle**
-   **KOUKPONOU Sonagnon**

### **Question 1:** Revue théorique

-   ***Question 1.1:*** Brève comparaison des différentes approches discutées par les auteurs pour estimer l'impact des immigrants sur le marché du travail sur les autochtones

On peut distinguer trois approches :

-   **L'approche par cellule nationale de compétences** : elle identifie l'effet de l'immigration sur un groupe d'expérience par rapport à un autre au sein des groupes de scolarité. Il s'agit d'études qui utilisent la variation des flux d'immigrants à travers les cellules d'expérience en matière d'éducation au niveau national, comme par exemple dans Borjas (2003).

-   **L'approche mixte** : elle prend en compte l'effet relatif de l'immigration d'un groupe de scolarité par rapport à un autre. Il s'agit principalement des études qui exploitent la variation du nombre total d'immigrants et les flux d'immigration entre les régions et entre les groupes de formation, comme par exemple dans Card (2001).

-   **L'approche spatiale pure** : récupère l'effet total de l'immigration qui, contrairement aux deux premières approches, prend en compte les complémentarités entre cellules de compétences et entre capital et travail.

<br/>

**COMPARAISON:**

L'approche par cellule nationale de compétences tend à produire **des effets salariaux plus négatifs** pour les autochtones en réponse à l'immigration que l'approche mixte. Au contraire, les estimations obtenues à partir de l'approche spatiale pure varient considérablement en fonction du groupe de compétences étudiées.

-   ***Question 1.2:*** Explication du déclassement des compétences observé chez les immigrants récents

-   ***Question 1.3:*** Effet du déclassement des compétences sur les estimations

Procéder à la répartition des immigrés dans des groupes de compétences en fonction de leurs compétences mesurées peut conduire à des erreurs de classification et nuire sérieusement aux estimations des réponses salariales des autochtones à l'immigration. Par exemple dans le contexte américain, le déclassement peut surestimer l'impact négatif de l'immigration à la fois dans l'approche de cellule nationale de compétences et dans l'approche mixte, mais particulièrement dans l'approche de cellule nationale de compétences.

### **Question 2:** Tâches de réplication à partir du dataframe `census_acs_2000.dta`

**LES LIBRAIRIES UTILES**

```{r, echo=TRUE, message=FALSE, warning=FALSE}

library(haven)
library(tidyverse)
library(stargazer) 

```

**IMPORTATION DE LA BASE DE DONNEES ET EXTRACTION**

```{r, echo=TRUE, message=FALSE, warning=FALSE}
path <- "C:/Users/Mauricette/Desktop/"
read_dta(paste0(path, "census_acs_2000.dta")) %>%
  select(year, age, labforce, wkswork2, incwage, classwkr, educd, race,
         marst, empstat, bpld, yrimmig, sex, serial, occ) ->
  acs2000

#visualisation
head(acs2000) 
```

**ANALYSE EXPLORATOIRE: PRELIMINAIRES**

-   Délimitation de l'échantillon de travailleurs i.e la population active celle agée entre 18 à 65 ans

```{r, echo=TRUE, message=FALSE, warning=FALSE}
acs2000 %>%
  filter(age >=18 & age <=65 & labforce == 2,classwkr == 2) -> acs2000

```

-   Création et recodage de variables :

***weeks*** : Cette variable est calculée en multipliant différents multiplicateurs par les catégories de la variable `wkswork2`.

***lnw*** : Cette variable est calculée avec le logarithme naturel de la variable `incwage` diviser par la variable `weeks`.

```{r, echo=TRUE, message=FALSE, warning=FALSE}
acs2000 %>%
  mutate(weeks = 7 * (wkswork2 == 1) + 20 * (wkswork2 == 2) +
           33 * (wkswork2 == 3) +
           43.5 * (wkswork2 == 4) + 48.5 * (wkswork2 == 5) +
           51 * (wkswork2 == 6)) %>%
  mutate(lnw = log(incwage / weeks)) %>%
  filter(!is.na(lnw), lnw != -Inf, lnw != Inf) ->
  acs2000 

```

***foreign*** : la nouvelle variable prendra la valeur "TRUE" si la valeur de `bpld` est supérieure ou égale à 15000.

***immclass*** : Ajoute une nouvelle variable initialisée à `NA` puis modifie la valeur de la colonne `immclass` en 1 si la valeur de la colonne `foreign` est égale à 1 et si la différence entre les valeurs des colonnes `year` et `yrimmig` est inférieure ou égale à 2.

Modifie la valeur de la colonne `immclass` en 2 si la valeur de la colonne `foreign` est égale à 1 et si la différence entre les valeurs des colonnes `year` et `yrimmig` est supérieure à 2 et inférieure ou égale à 5, etc.

```{r, echo=TRUE, message=FALSE, warning=FALSE}
acs2000 %>%
  mutate(foreign = (bpld>=15000),
         immclass = case_when(foreign==1 & year-yrimmig<=2 ~ 1,
                              foreign==1 & year-yrimmig> 2 & year-yrimmig<=5 ~ 2,
                              foreign==1 & year-yrimmig> 5 & year-yrimmig<=10 ~ 3,
                              foreign==1 & year-yrimmig> 10 & !is.na(year-yrimmig) ~ 4
         ),
  agecat= case_when(age >= 18 & age <= 25 ~ 1, 
                             age > 25 & age <= 35 ~ 2,
                             age > 35 & age <= 45 ~ 3,
                             age > 45 & age <= 55 ~ 4, 
                             age > 55 & age <= 65 ~ 5,
                             TRUE ~ NA_real_
          ))-> acs2000                 
```

***Schooling*** : La première mutation initialise la variable `schooling` à 0 par défaut. Ensuite les codes qui suivent mettent à jour la colonne `schooling` dans le tableau de données *acs2000* en remplaçant les zéros en fonction des valeurs de la colonne `educd` dans chaque ligne.

***pe*** : L'expérience professionnelle qui est donnée par la différence entre 'age' et la somme de 6 et 'schooling'.

```{r, echo=TRUE, message=FALSE, warning=FALSE}
acs2000 %>%    
  mutate(schooling = 0) %>%
  mutate(schooling = ifelse(educd == 10, 2, schooling)) %>%
  mutate(schooling = ifelse(educd == 13, 2.5, schooling)) %>%
  mutate(schooling = ifelse(educd == 14, 1, schooling)) %>%
  mutate(schooling = ifelse(educd == 15, 2, schooling)) %>%
  mutate(schooling = ifelse(educd == 16, 3, schooling)) %>%
  mutate(schooling = ifelse(educd == 17, 4, schooling)) %>%
  mutate(schooling = ifelse(educd == 20, 6.5,schooling)) %>%    
  mutate(schooling = ifelse(educd == 21, 5.5, schooling)) %>%
  mutate(schooling = ifelse(educd == 22, 5, schooling)) %>%
  mutate(schooling = ifelse(educd == 23, 6, schooling)) %>%
  mutate(schooling = ifelse(educd == 25, 7, schooling)) %>%
  mutate(schooling = ifelse(educd == 24, 7.5, schooling)) %>%    
  mutate(schooling = ifelse(educd == 26, 8, schooling)) %>%
  mutate(schooling = ifelse(educd == 30, 9, schooling)) %>%
  mutate(schooling = ifelse(educd == 40, 10, schooling)) %>%    
  mutate(schooling = ifelse(educd == 50 | educd == 61, 11, schooling)) %>%
  mutate(schooling = ifelse(educd == 60 | (educd >= 62 & educd <= 64), 12, schooling)) %>%
  mutate(schooling = ifelse(educd >= 65 & educd <= 71, 13, schooling)) %>%
  mutate(schooling = ifelse(educd >= 80 & educd <= 90, 14, schooling)) %>%
  mutate(schooling = ifelse(educd == 90, 15, schooling)) %>%
  mutate(schooling = ifelse(educd == 100 | educd == 101, 16, schooling)) %>%
  mutate(schooling = ifelse(educd == 110, 17, schooling)) %>%
  mutate(schooling = ifelse(educd == 111 | educd == 114, 18, schooling)) %>%
  mutate(schooling = ifelse(educd == 112, 19, schooling)) %>%
  mutate(schooling = ifelse(educd == 113 | educd > 114, 20, schooling)) %>%
  mutate(pe = as.integer(age - 6 - schooling))  ->
  acs2000
```

L'instruction ci-dessous filtre le dataframe en gardant uniquement les lignes où `lnw` n'est pas NA (Not Available ou Non Applicable) et où `pe` est supérieur ou égal à 1 et inférieur ou égal à 40. En d'autres termes, les lignes avec des valeurs manquantes de `lnw` sont exclues et seules les lignes avec des valeurs de `pe` comprises entre 1 et 40 sont gardées

```{r, echo=TRUE, message=FALSE, warning=FALSE, results='hold'}
acs2000 %>%
  filter(!is.na(lnw), pe >= 1 & pe <= 40) ->
  acs2000

# Affichage des colonnes en horizontale avec leurs types respectifs
glimpse(acs2000) 
```

-   ***Question 2.1:*** Explorons la présence d'un déclassement des compétences, en estimant les regressions salariales incluant le niveau de scolarité comme variable catégorielle et l'interaction entre le niveau de scolarité et l'âge.

```{r, echo=TRUE, message=FALSE, warning=FALSE, results='hold'}
modf <-lnw ~ educd+age+I(age^2)+ sex+educd:age + foreign

reg1 <- lm(modf, data=acs2000, subset=(foreign==0 |immclass==1))
reg2 <- lm(modf, data=acs2000, subset=(foreign==0 |immclass==2))
reg3 <- lm(modf, data=acs2000, subset=(foreign==0 |immclass==3))
reg4 <- lm(modf, data=acs2000, subset=(foreign==0 |immclass==4))

stargazer(reg1,reg2,reg3,reg4,
          dep.var.caption="0-2 years 3-5 years 6-10 years more than 10 years",dep.var.labels="",
          omit.table.layout = "n", star.cutoffs = NA,
          keep.stat=c("n", "rsq"),no.space=TRUE,
          keep=c("foreignTRUE"),
          header=TRUE,
          title="Table replication", type="text"
)

```

**PREDICTION DU LOGARITHME DES SALAIRES**

```{r, echo=TRUE, message=FALSE, warning=FALSE}
acs2000$lnw_pred <- NA
acs2000$sigma <- NA

acs2000$in_reg <- (acs2000$sex == 1 & acs2000$foreign == 0)
mod <- lm(lnw ~ foreign + age + educd + educd*age,
          data=acs2000, subset=in_reg)
acs2000$sigma[acs2000$in_reg] <- (mod$residuals)^2
acs2000$lnw_pred[acs2000$sex == 1] <- predict(mod, acs2000[acs2000$sex == 1,])

```

```{r, echo=TRUE, message=FALSE, warning=FALSE}
acs2000 %>% arrange(serial) -> acs2000
set.seed(1234)

for (i in min(acs2000$agecat):max(acs2000$agecat)) {
  for (k in 1:2) {
    for (j in min(acs2000$educd):max(acs2000$educd) ) {
      acs2000$in_reg <- (acs2000$agecat==i & acs2000$sex==k & acs2000$educd==j)
      N = sum(acs2000$in_reg)
      if (N>0) {
        sdS = sqrt(mean(acs2000$sigma[acs2000$in_reg], na.rm=TRUE))
        # cat(i, k, j, "N=",N, "  ", sdS, "\n")
        acs2000$lnw_pred[acs2000$in_reg] = acs2000$lnw_pred[acs2000$in_reg] +
          rnorm(N,0,sdS)
      }
    }
  }
}

acs2000 %>%
  filter(!is.na(lnw_pred)) %>%
  mutate(lnw_pred = ifelse(foreign==0, lnw,lnw_pred)) ->
  acs2000
```

-   ***Question 2.2:*** Computation of the percentile ranks in actual and predicted wage distribution


-  Calcule des rangs centiles pour les salaires réels

```{r, echo=TRUE, message=FALSE, warning=FALSE}

acs2000 <- acs2000 %>% 
  mutate(x = (foreign==0)) %>% 
  arrange(lnw) %>% # sorting
  mutate(rank = cumsum(x) ) %>% # somme cumulée de l'indicateur qui prouve qu'on n'est pas immigrée
  mutate(rank = rank / max(rank)) %>% # normalisation to [0,1] 
  mutate(immpos = ifelse(log(rank/(1-rank)) < Inf, log(rank/(1-rank)), NA)) # première transformation des rangs par la transformation logarithmique
  
  
#estimation de la densité

dens_imm =density(acs2000$immpos[acs2000$foreign == 1])
 
#Retransformation  

dens_imm$x2 <- exp(dens_imm$x) / (1 + exp(dens_imm$x))

```


-   Calcule des rangs centiles pour les salaires prédits 

Il s'agit normalement de Calculer la variable  `Foreign predicted` et d'appliquer la meme pocédure comme pour pour `lnw_pred`.   Voici la procédure que nous proposons : 


```{r, results='hide'}
# La partie des rangs centiles pour lnw_pred 

# Calculer  le Foreign_pred et appliquer la même procédure: 

# Construction du modèle de régression logistique
modele <- glm(foreign ~ bpld + immclass, data = acs2000, family = "binomial")

# Résumé du modèle
#summary(modele)

acs2000 <- acs2000 %>%
  mutate(foreign_pred = predict(modele, newdata = ., type = "response")) %>%
  mutate(foreign_pred = ifelse(is.na(foreign_pred), 0, foreign_pred)) %>%
  mutate(foreign_pred = as.logical(foreign_pred))

acs2000 <- acs2000 %>%
  mutate(y = (foreign_pred == 0)) %>%
  arrange(lnw_pred) %>% # sorting
  mutate(rank_pred = cumsum(y)) %>%
  mutate(rank_pred = rank_pred / max(rank_pred)) %>%
  mutate(immpos_pred = ifelse(log(rank_pred/(1-rank_pred)) < Inf, log(rank_pred/(1-rank_pred)), NA))


#Estimation de la densité : 

dens_imm_pred= density(acs2000$immpos_pred[acs2000$foreign_pred == 1])

# Puis la retransformation  

dens_imm_pred$y2 <- exp(dens_imm_pred$y) / (1 + exp(dens_imm_pred$y))

```

Cependant en optant pour cette option nous avons rencontré dans le calcul de la variable `Foreign predicted`. Voici le code similaire que nous avons finalement utilisé  pour calculer les rangs centiles prédits: 


```{r}
#une autre méthode que voici : 

# Création de la fonction de distribution cumulative empirique (ECDF) 

ecdf_lnwpr <- ecdf(acs2000$lnw)
centiles_predi <- ecdf_lnwpr(seq(min(acs2000$lnw_pred), max(acs2000$lnw_pred), length.out = 101))
centiles_predi = centiles_predi[1:100]
rang_p <- log(centiles_predi /(1-centiles_predi))

# Estimation de la densité de la distribution des rangs transformés :

dens_imm1 <- density(rang_p)

#Puis la rétransformation  

inv_transform <- function(x) {return (exp(x) / (1 +exp(x)))}

x1= inv_transform(dens_imm1$x)
dens1=density(x1)

plot(dens1,xlim=c(0,0.9))
lines(dens1)

```



```{r}
# Le graphique  

# Réinitialisation des limites du clip après le graphique

# Tracer la première graphique
plot(dens_imm$x2,
     dens_imm$y /(dens_imm$x2 * (1-dens_imm$x2)), type = "l", lty = 2, #lwd=1,
     ylab="", xlab="rank", col = "green", xlim = c(0.05, 0.95))


# Tracer la deuxième graphique # A corriger
lines(dens1, type="l",
      ylab="", xlab="rank", col = "black")

# Tracer la troisième graphique
abline(h = 1, col = "grey")

axis(1, at = c(0.2, 0.4, 0.6, 0.8))
# Ajouter la légende
legend("topright", legend = c("Foreign predicted", "Foreign", "Natives"),
       col = c("black", "green", "grey"), lty = c(1, 2, 1))

```


